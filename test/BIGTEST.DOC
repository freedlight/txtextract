// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
// cvttest.c - text conversion utility - test program

#define SystemSixOrLater 1
#define SystemSevenOrLater 1

#include <Fonts.h>
#include <Memory.h>
#include <ToolUtils.h>
#include <StandardFile.h>
#include <StdIO.h>
#include <StdLib.h>
#include <String.h>
#include <Strings.h>
#include "CVT.h"

#ifndef applec
#error This is only for Macintosh
#endif

void InitAll(void)
{
	InitGraf(&(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void IOError(short err, char *s)
{
	char errstr[32];

	sprintf(errstr, "Error code %d", err);
	paramtext(errstr, s, 0, 0);
	StopAlert(128, NULL);
	ExitToShell();
}

void MessageBox(char *s1, char *s2, char *s3)
{
	paramtext(s1, s2, s3, 0);
	StopAlert(129, NULL);
}

#define MAXBUFFER			32767

void main(void)
{
	char *p;
	OSErr err, oerr;
	short fo;
	long len, tbef, taft;
	CVTPARMS glob;
	CursHandle watch;
	char oname[64], temp[64], temp2[64];
	SFTypeList styp = { 'TEXT' };
	StandardFileReply reply;

	InitAll();
// init globals
	glob.usetabs = 0;
	glob.tabwidth = 1;
	glob.testonly = 0;
	glob.fileout = 0;
// get file to convert
	StandardGetFile(NULL, -1, styp, &reply);
	if (!reply.sfGood)
		ExitToShell();
	glob.iname = reply.sfFile;
// make output file name
	BlockMove(glob.iname.name, oname, 64);
	p2cstr(oname);
	if ((p = strrchr(oname, '.')) != 0)
		*p = 0;
	strcat(oname, ".TXT");
	c2pstr(oname);
// setup rest of global block
	if ((glob.outp = (char *)NewPtr(MAXBUFFER)) == NULL)
		IOError(0, "No memory for buffer");
	glob.maxcnt = MAXBUFFER;
// convert it
	watch = GetCursor(4);
	SetCursor(*watch);
	tbef = TickCount();
	err = ConvertText(&glob);
	taft = TickCount();
	InitCursor();
	switch (err)
	{
	// error returns
		case ERR_None:
			break;
		case ERR_NoInput:
			IOError(err, "cannot open input file");
		case ERR_UnknownType:
			IOError(err, "Sorry, Unknown format");
		case ERR_UnsupportedType:
			IOError(err, "Not yet supported");
		case ERR_TextNotFound:
			IOError(err, "Unable to locate text in file");
		case ERR_UnexpectedEOF:
			IOError(err, "Unexpected end of file");
	}
	if (glob.overflow)
		strcpy(temp, "file truncated");
	else
		sprintf(temp, "%d chars converted", glob.outcnt);
	sprintf(temp2, "took %ld ticks", taft - tbef);
	switch (glob.ftype)
	{
		case CVT_ASCII:
			MessageBox("ASCII", temp, temp2);
			break;
		case CVT_WP51:
			MessageBox("WordPerfect", temp, temp2);
			break;
		case CVT_WORDDOS:
			MessageBox("Word For DOS", temp, temp2);
			break;
		case CVT_WORDWIN:
			MessageBox("Word For Windows", temp, temp2);
			break;
		case CVT_AMIPRO:
			MessageBox("AMI Pro", temp, temp2);
			break;
		case CVT_MSWRITE:
			MessageBox("Windows Write", temp, temp2);
			break;
		case CVT_WORDMAC3:
			MessageBox("Word For Mac 3.x", temp, temp2);
			break;
		case CVT_WORDMAC4:
			MessageBox("Word For Mac 4.x/5.x", temp, temp2);
			break;
		case CVT_RTF:
			MessageBox("RTF 1.0", temp, temp2);
			break;
		case CVT_POSTSCR:
			MessageBox("Postscript", temp, temp2);
			break;
	}
// output file from converted data
	FSDelete(oname, 0);
	if ((oerr = Create(oname, 0, 'MPS ', 'TEXT')) != noErr)
		IOError(oerr, "Error creating output file");
	if ((oerr = FSOpen(oname, 0, &fo)) != noErr)
		IOError(oerr, "Error opening output file");
	len = glob.outcnt;
	FSWrite(fo, &len, glob.outp);
	if ((oerr = FSClose(fo)) != noErr)
		IOError(oerr, "Error closing output file");
// delete output file on error
	else if (err != noErr)
		FSDelete(oname, 0);
	DisposePtr((Ptr)glob.outp);
	ExitToShell();
}
